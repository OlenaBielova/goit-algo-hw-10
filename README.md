# goit-algo-hw-10

Висновки до завдання 1 щодо ефективності алгоритмів (Greedy vs DP)

Оптимальність для нашого набору монет [50, 25, 10, 5, 2, 1]:
Жадібний алгоритм (Greedy) дає оптимальний результат (мінімальну кількість монет). Це «канонічна» система номіналів, для якої жадібний підхід збігається з глобальним оптимумом.

Швидкодія:
Greedy працює дуже швидко й практично не залежить від величини суми (час ~ пропорційний кількості номіналів).

DP має час і пам’ять, що лінійно залежать від суми (будує таблицю до amount). Для великих сум це відчутно повільніше й «важче».

Пам’ять:
Greedy — мінімальна (константна).
DP — O(S) додаткової пам’яті (для всіх проміжних сум).

Надійність оптимуму:
Greedy оптимальний у даному випадку (і взагалі — для канонічних наборів).
DP гарантує оптимум для будь-яких номіналів, тому універсальніший, але дорожчий за ресурси.

Практичний вибір для цієї задачі:
Використовувати Greedy — він простий, найшвидший і дає той самий оптимальний розклад, що й DP. DP має сенс лише як «еталон перевірки» або якщо набір монет зміниться на нестандартний.

Висновки до завдання 2: метод Монте-Карло vs аналітика / quad

Результати.
Для N=200000 Монте-Карло дало ~2.664 з невеликою похибкою; аналітика та quad — 2.66666667 (збігаються).

Час.
quad спрацював за ~0.04 ms і дав точний результат; Монте-Карло помітно повільніше, а час росте зі збільшенням N (час на один семпл майже сталий).

Точність.
При збільшенні N стандартна помилка зменшується, інтервал звужується; щоб суттєво підвищити точність, потрібно сильно збільшувати N.

Практичний вибір для цієї задачі:
Для 1D прикладу зручно використовувати quad/аналітику (швидше й точніше);
Монте-Карло — робочий, але менш ефективний тут.
